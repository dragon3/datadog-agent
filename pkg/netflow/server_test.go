package netflow

import (
	"bytes"
	"fmt"
	"github.com/DataDog/datadog-agent/pkg/aggregator"
	"github.com/DataDog/datadog-agent/pkg/aggregator/mocksender"
	"github.com/DataDog/datadog-agent/pkg/config"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"net"
	"strconv"
	"strings"
	"testing"
	"time"
)

func getFreePort() uint16 {
	var port uint16
	for i := 0; i < 5; i++ {
		conn, err := net.ListenPacket("udp", ":0")
		if err != nil {
			continue
		}
		conn.Close()
		port, err = parsePort(conn.LocalAddr().String())
		if err != nil {
			continue
		}
		//listener, err := startSNMPTrapListener(&Config{Port: port}, nil)
		//if err != nil {
		//	continue
		//}
		//listener.Close()
		return port
	}
	panic("unable to find free port for starting the trap listener")
}

func parsePort(addr string) (uint16, error) {
	_, portString, err := net.SplitHostPort(addr)
	if err != nil {
		return 0, err
	}

	port, err := strconv.ParseUint(portString, 10, 16)
	if err != nil {
		return 0, err
	}
	return uint16(port), nil
}

func TestNewNetflowServer(t *testing.T) {
	data := []byte{
		0x00, 0x05, 0x00, 0x06, 0x00, 0x82, 0xc3, 0x48, 0x5b, 0xcd, 0xba, 0x1b, 0x05, 0x97, 0x6d, 0xc7,
		0x00, 0x00, 0x64, 0x3d, 0x08, 0x08, 0x00, 0x00, 0x0a, 0x80, 0x02, 0x79, 0x0a, 0x80, 0x02, 0x01,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x02, 0x4e,
		0x00, 0x82, 0x9b, 0x8c, 0x00, 0x82, 0x9b, 0x90, 0x1f, 0x90, 0xb9, 0x18, 0x00, 0x1b, 0x06, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x02, 0x77, 0x0a, 0x81, 0x02, 0x01,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x94,
		0x00, 0x82, 0x95, 0xa9, 0x00, 0x82, 0x9a, 0xfb, 0x1f, 0x90, 0xc1, 0x2c, 0x00, 0x12, 0x06, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x81, 0x02, 0x01, 0x0a, 0x80, 0x02, 0x77,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xc2,
		0x00, 0x82, 0x95, 0xa9, 0x00, 0x82, 0x9a, 0xfc, 0xc1, 0x2c, 0x1f, 0x90, 0x00, 0x16, 0x06, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x02, 0x01, 0x0a, 0x80, 0x02, 0x79,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x09, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x01, 0xf1,
		0x00, 0x82, 0x9b, 0x8c, 0x00, 0x82, 0x9b, 0x8f, 0xb9, 0x18, 0x1f, 0x90, 0x00, 0x1b, 0x06, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x02, 0x01, 0x0a, 0x80, 0x02, 0x79,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x09, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x02, 0x2e,
		0x00, 0x82, 0x9b, 0x90, 0x00, 0x82, 0x9b, 0x9d, 0xb9, 0x1a, 0x1f, 0x90, 0x00, 0x1b, 0x06, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x02, 0x79, 0x0a, 0x80, 0x02, 0x01,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x0b, 0xac,
		0x00, 0x82, 0x9b, 0x90, 0x00, 0x82, 0x9b, 0x9d, 0x1f, 0x90, 0xb9, 0x1a, 0x00, 0x1b, 0x06, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
	buf := bytes.NewBuffer(data)

	port := getFreePort()

	// collect_device_metadata: false
	config.Datadog.SetConfigType("yaml")
	err := config.Datadog.ReadConfig(strings.NewReader(fmt.Sprintf(`
network_devices:
  netflow:
    enabled: true
    aggregator_flush_interval: 1
    listeners:
      - flow_type: netflow5 # netflow, sflow, ipfix
        bind_host: 0.0.0.0
        port: %d # default 2055 for netflow
`, port)))
	require.NoError(t, err)

	// TODO: Add server tests
	demux := aggregator.InitTestAgentDemultiplexerWithFlushInterval(10 * time.Millisecond)
	defer demux.Stop(false)

	sender := mocksender.NewMockSender("")
	sender.On("EventPlatformEvent", mock.Anything, mock.Anything).Return()
	sender.On("Count", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return()

	demux.SetMockDefaultSender(sender)

	server, err := NewNetflowServer(demux)
	require.NoError(t, err, "cannot start Netflow Server")
	assert.NotNil(t, server)

	//p := make([]byte, 2048)
	conn, err := net.Dial("udp", fmt.Sprintf("0.0.0.0:%d", port))
	if err != nil {
		fmt.Printf("Some error %v", err)
		return
	}
	count, err := conn.Write(data)
	require.NoError(t, err)
	fmt.Println("bytes count: ", count)
	//fmt.Fprintf(conn, "Hi UDP Server, How are you doing?")
	//_, err = bufio.NewReader(conn).Read(data)
	//if err == nil {
	//	fmt.Printf("%s\n", data)
	//} else {
	//	fmt.Printf("Some error %v\n", err)
	//}

	// language=json
	//	event := []byte(`
	//{
	//    "bytes": 194,
	//    "destination": {
	//        "ip": "10.128.2.119",
	//        "mac": "",
	//        "mask": "",
	//        "port": 8080
	//    },
	//    "direction": "ingress",
	//    "egress": {
	//        "interface": {
	//            "index": 7
	//        }
	//    },
	//    "end": 1540209169,
	//    "ether_type": 2048,
	//    "exporter": {
	//        "ip": "127.0.0.1"
	//    },
	//    "host": "COMP-C02CF0CWLVDP",
	//    "ingress": {
	//        "interface": {
	//            "index": 1
	//        }
	//    },
	//    "ip_protocol": 6,
	//    "namespace": "default",
	//    "next_hop": {
	//        "ip": "0.0.0.0"
	//    },
	//    "packets": 3,
	//    "sampling_rate": 0,
	//    "source": {
	//        "ip": "10.129.2.1",
	//        "mac": "00:00:00:00:00:00",
	//        "mask": "0.0.0.0/24",
	//        "port": 49452
	//    },
	//    "start": 1540209168,
	//    "tcp_flags": [
	//        "SYN",
	//        "ACK"
	//    ],
	//    "tos": 0,
	//    "type": "netflow5"
	//}`)

	time.Sleep(2 * time.Second)
	sender.AssertEventPlatformEvent(t, "abc", "network-devices-metadata")

	conn.Close()

	server.Stop()

	fmt.Println(port)
	fmt.Println(buf)
}
